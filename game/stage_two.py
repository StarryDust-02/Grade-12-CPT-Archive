from core.game import *
from game.enemy import horizontal_redsprite
from game.enemy import second_stage_bsprite 
from core.enemy import *
from core.barrage import *
from game import stage_three
import random 
import math

class StageTwo(Game):
    """
    This class represents Stage two of the Game.
    In this stage, there is no boss however, there are going to be number of minions.
    This class inherites Game class from core folder.
    
    Attribute:
        MUSIC(dict): dictionary of music played in this stage.
    """
    MUSIC = {}

    def __init__(self, screen, p: int=None):
        """
        This is init method which initializes StageTwo object

        Args:
            screen (Surface): Pygame's surface object used as a window or screen for display.
            p (int): The integer denoting player's character.

        Attributes:
            phase_list(list): overrides the phase_list attribute of the parent class.

        """
        super().__init__(screen, p)
        self.phase_list = [self.phase_title, self.phase_zero, self.phase_one, self.phase_two]
        self.mob_list = [horizontal_redsprite.HorizontalRedSprite, second_stage_bsprite.SSBlueSprite]
        
        # Loads and plays music
        m = utility.load_music('Kanata')
        StageTwo.MUSIC['kanata'] = m
        utility.play_music(StageTwo.MUSIC['kanata'])
    
    def draw(self):
        """
        This function draws the stage.
        """
        # change the background to brown, everything else remain the same.
        surface = pygame.Surface(STAGE_WIDTH_HEIGHT)
        surface.fill((157, 127, 97))
        self.score_board.show(self.screen)
        self.effect_group.draw(surface)
        self.bullet_group.draw(surface)
        self.player.show(surface)
        self.item_group.draw(surface)
        self.barrage_group.draw(surface)
        self.enemy_group.draw(surface)
        self.bomb_group.draw(surface)
        self.effect_group.draw(surface)
        self.boss_group.draw(surface)

        self.screen.blit(surface, STAGE_RECT)

    def search_mob(self, s_type='red'):
        """
        This functions searches for the mob type and create instance of that mob.

        Args:
            s_type(str): Type of the sprite. Choice of "red" or "blue" or any string. Defaults to "red".
            If any string is given, create a greensprite that does not shoot anything.
        
        Return:
            return index of the mob searched from this function.
        """
        for m in range(len(self.mob_list)):
            if self.mob_list[m].name == s_type:
                return m
        return -1

    def generate_mob(self, s_type="red"): 
        """
        This function creates the minion in the game for players to defeat.
        Based on an current phase of the game stage, the behaviour of the minions
        generated by this function drastically changes.
        The minion being created by this function is VerticalRedSprite object.
        Each minion is added to the enemy group.
        
        Args:
            s_type(str): Type of the sprite. Choice of "red" or "blue" or any string. Defaults to "red".
            If any string is given, create a greensprite that does not shoot anything. 
        """
        mob_ind = self.search_mob(s_type)
        if mob_ind != -1:
            new_mob = self.mob_list[mob_ind](self)
        else:
            # Misc.enemies do not shoot anything
            new_mob = Enemy(self, 'greensprite')
            new_mob.bounds = -50, -1000, STAGE_WIDTH_HEIGHT[0] + 50, STAGE_WIDTH_HEIGHT[1] + 50
            new_mob.velocity = vector.objVector(0, 200*MEASURE_UNIT)
            new_mob.acceleration = vector.objVector(0, -2.5*MEASURE_UNIT)

        random_x = random.randint(0, STAGE_WIDTH_HEIGHT[0])
        random_y = random.randint(0, STAGE_WIDTH_HEIGHT[1]//2)
        new_mob.position = vector.objVector(random_x,random_y)
        new_mob.fire_pattern = [StageTwo.default_custom_fire, self.custom_fire_1, self.custom_fire_1]
        if self.phase == 0:
            new_mob.health = 2
        elif self.phase == 1:
            new_mob.health = 6
            new_mob.velocity.norm = 200*MEASURE_UNIT
        else:
            new_mob.health = 6
        self.enemy_group.add(new_mob)

    @classmethod
    def sort_nested_list(cls, lst):
        """
        Sorts given nested list based on the first element of the inner list

        Args:
            lst(list): nested list
        
        Returns:
            Sorted list
        """
        for times_through in range(len(lst) - 1):
            i = 0
            is_sorted = True
            while i < len(lst) - 1 - times_through:  # single-pass
                a = lst[i][0]
                b = lst[i+1][0]
                if a > b:
                    temp = lst[i]
                    lst[i] = lst[i+1]
                    lst[i+1] = temp
                    is_sorted = False
                i += 1
            if is_sorted == True:
                break
        return lst

    @staticmethod
    def default_custom_fire(child):
        """
        The default fire pattern of the minion in this stage.
        This fire pattern randomly chooses one of the danmaku patterns.

        Args:
            child(Enemy): An enemy or child of Enemy class that will used this fire pattern.
        """
        fire_pattern = [[1, Enemy.defualt_danmaku_pattern_001], 
                        [3, Enemy.defualt_danmaku_pattern_003],
                        [2, Enemy.defualt_danmaku_pattern_002], 
                        [5, Enemy.defualt_danmaku_pattern_005],
                        [4, Enemy.defualt_danmaku_pattern_004]]
        fire_pattern = StageTwo.sort_nested_list(fire_pattern)
        
        r = random.randint(0, 4)
        if r == 3:
            fire_pattern[r][1](child)
        else:
            fire_pattern[r][1](child, count=12)
        
            
    def custom_fire_1(self, child):
        """
        The second fire pattern of the minion in this stage.
        The minion with this fire pattern shoots diamond shaped barrages.
        The barrage shoots out directly from the minion.

        Args:
            child(Enemy): An enemy or child of Enemy class that will used this fire pattern.
        """
        b = Barrage(self, ['diamond', '1'])
        b.position[0] = child.position[0] 
        b.position[1] = child.position[1]
        b.velocity = (self.player.position - b.position)
        b.velocity.norm = 600*MEASURE_UNIT
        self.barrage_group.add(b)
        child.fire_timer = 0
    
    def custom_fire_2(self, child):
        """
        The third fire pattern of the minion in this stage.
        This fire pattern is not used in this stage due to balancing issue.

        Args:
            child(Enemy): An enemy or child of Enemy class that will used this fire pattern.
        """
        b = Barrage(self, ['square', '4'])
        b.position[0] = child.position[0]
        b.position[1] = child.position[1] + 10
        b.velocity = (self.player.position - b.position)
        b.velocity.norm = 200*MEASURE_UNIT
        self.barrage_group.add(b)
        child.fire_timer = 0

    def custom_fire_3(self, child):
        """
        The fourth fire pattern of the minion in this stage.
        This fire pattern is not used in this stage due to balancing issue.

        Args:
            child(Enemy): An enemy or child of Enemy class that will used this fire pattern.
        """
        time = child.timer
        distance = 6
        radius = 100 

        #start
        sx = child.position[0]
        sy = child.position[1] - radius
        sangle = math.pi/10 + math.pi/2

        delta_time = 0
        sst = 0

        while sst <= 6:
            i = 0
            while True:
                delta_time += 0.3
                sx += math.cos(sangle)*distance
                sy += math.sin(sangle)*distance
                
                if (sx - child.position[0])**2 + (sy - child.position[1])**2 > radius*radius:
                    sst += 1
                    sangle -= (math.pi - math.pi/5)
                    break
                
                for j in range(9):
                    new = Barrage(child, ['barrier', str(j+1)])
                    new.position = vector.objVector(sx, sy)
                    new.correct_start_position = False
                    new.phase_list = [self.custom_fire_update]
                    
                    new.custom_messages = {"start_angle": math.degrees(math.pi - 2*math.pi/5*j), "base_angle": math.degrees(sangle - math.pi + math.pi/20*i), "delay": int(delta_time)}
                    try:
                        child.fire_pattern_temp[time + int(delta_time)].append(new)
                    except:
                        child.fire_pattern_temp[time + int(delta_time)] = []
                        child.fire_pattern_temp[time + int(delta_time)].append(new)
                i += 1

    def custom_fire_update(self, child):
        """
        This function is used as one of the phases of barrage in custom_fire_2.
        Changes the velocity. i.e., changes the angle and the speed of the child.

        Args:
            child(barrage): The barrage created by a custom fire pattern.
        """
        if child.timer + child.custom_messages["delay"] == 1.5*FRAME_PER_SECOND:
            child.velocity = vector.objVector(500*MEASURE_UNIT,0)
            child.velocity.angle = child.custom_messages["start_angle"]
        elif 2*FRAME_PER_SECOND > child.timer + child.custom_messages["delay"] > 1.5*FRAME_PER_SECOND:
            child.velocity.norm = child.velocity.norm - 10*MEASURE_UNIT
        elif child.timer + child.custom_messages["delay"] >= 2*FRAME_PER_SECOND:
            child.velocity.angle = child.custom_messages["base_angle"]
    
    def phase_title(self):
        """
        This function print title for this stage.
        It immediately goes to the next phase after 3*FRAME_PER_SECOND seconds.
        """
        if self.timer == 1:
            title1 = text.Text(JAP_FONT_PATH, 36, (255,255,255), '')
            title1.position = vector.objVector(STAGE_WIDTH_HEIGHT[0]/2, STAGE_WIDTH_HEIGHT[1]/3)
            title1.life_timer = 5*FRAME_PER_SECOND
            title2 = text.Text(ENG_FONT_PATH, 24, (255,255,255), 'Presented by Jaywon Han')
            title2.position = vector.objVector(STAGE_WIDTH_HEIGHT[0]/2, STAGE_WIDTH_HEIGHT[1]/3 + 100)
            title2.life_timer = 5*FRAME_PER_SECOND
            self.effect_group.add(title1)
            self.effect_group.add(title2)
        
        elif self.timer == 3*FRAME_PER_SECOND:
            self.next_phase()


    def phase_zero(self):
        """
        This function represents the phase zero of the game.
        This phase spawns a minion every 60 seconds.
        If timer reaches 5*FRAME_PER_SECOND, then move on to the next phase
        and reset timer.
        """
        if 10*FRAME_PER_SECOND > self.timer >= 0 and self.timer % FRAME_PER_SECOND == 0:
            self.generate_n_mob(2, 'green')
            self.generate_n_mob(2, 'red')
        elif self.timer % (FRAME_PER_SECOND*2) == 0 and self.timer >= 10*FRAME_PER_SECOND:
                self.generate_n_mob(4, 'red')

        if self.timer >= 20*FRAME_PER_SECOND: # to next phase
            self.timer = 0
            self.phase += 1
    
    def phase_one(self):
        """
        This function represents the phase one of the game.
        This phase spawns two minions every 90 seconds.
        If timer reaches 5*FRAME_PER_SECOND, then move on to the next phase
        and reset timer.
        """
        if 5*FRAME_PER_SECOND > self.timer >= 0 and self.timer % FRAME_PER_SECOND == 0:
            self.generate_n_mob(2, 'blue')
        elif 15*FRAME_PER_SECOND > self.timer >= 5*FRAME_PER_SECOND and self.timer % FRAME_PER_SECOND == 0:
            self.generate_n_mob(1, 'blue')
            self.generate_n_mob(2, 'green')
        elif self.timer >= 15*FRAME_PER_SECOND and self.timer % FRAME_PER_SECOND == 0:
            self.generate_n_mob(1, 'red')
            self.generate_n_mob(1, 'blue')
        if self.timer >= 20*FRAME_PER_SECOND: # to next phase
            self.timer = 0
            self.phase += 1
    
    def phase_two(self):
        """
        This fucntion represents the phase two of the game.
        This phase spawn two minions every 90 seconds.
        """
        if 5*FRAME_PER_SECOND > self.timer >= 0 and self.timer % FRAME_PER_SECOND == 0:
            self.generate_n_mob(2, 'blue')
            self.generate_n_mob(2, 'red')
        elif 15*FRAME_PER_SECOND > self.timer >= 5*FRAME_PER_SECOND and self.timer % (FRAME_PER_SECOND*2) == 0:
            self.generate_n_mob(3, 'red')
            self.generate_n_mob(6, 'green')
        elif 20*FRAME_PER_SECOND >= self.timer >= 15*FRAME_PER_SECOND and self.timer % FRAME_PER_SECOND == 0:
            self.generate_n_mob(1, 'red')
        elif self.timer > 20*FRAME_PER_SECOND:
            self.finished = True
    
    def stage_end(self):
        """
        This function ends the current stage and move on to the next stage which is stage three.S
        """
        
        return stage_three.StageThree(self.screen, self.player).run()

            
        
    def generate_n_mob(self, n: int, mob_type: str):
        """
        This fucntion generate n number of mobs using recursion.

        Args:
            n(int): The number of mobs to be generated.
            mob_type(str): The type of the mob
        """
        if n > 0:
            self.generate_mob(s_type=mob_type)
            self.generate_n_mob(n-1, mob_type)

        








